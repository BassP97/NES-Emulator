#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals, dead_code, unused_variables)]
pub use crate::implementation::data::State;
pub use crate::implementation::ops;
pub use crate::implementation::bus;


/*
Another simple file - this emulates the instruction at the 
current program counter, meaning it decodes the instruction
and calls the appropriate op function

We accomplish this using the classic, tried and true
big-ol-switch-statement method 

Documentation of the 6502 ISA: 
https://www.masswerk.at/6502/6502_instruction_set.html#BRK
*/

/*
All the addressing modes - this looks like a lot,
but most instructions only use a couple

Also, I made them all 4 characters long for the 
*aesthetic*, which I hope the reader appreciates
*/

//operand is AC (implied single byte instruction)
const accu: u8 = 0x00;
//operand is address $HHLL *
const abso: u8 = 0x01;
//operand is address; effective address is address incremented by X WITH carry 
const absX: u8 = 0x02;
//operand is address; effective address is address incremented by Y WITH carry
const absY: u8 = 0x03;
//operand is the immediate byte
const imme: u8 = 0x04;
//operand is implied
const impi: u8 = 0x05;//can't name it `impl' cuz that's a rust keyword - boo!
//operand is address; effective address is contents of word at address: C.w($HHLL)
const indr: u8 = 0x06;
//operand is zeropage address; effective address is word in (LL + X, LL + X + 1), inc. without carry: C.w($00LL + X)
const Xind: u8 = 0x07;
//operand is zeropage address; effective address is word in (LL, LL + 1) incremented by Y with carry: C.w($00LL) + Y
const indY: u8 = 0x08;
//branch target is PC + signed offset byte, which is the byte immediately following the instruction
const rela: u8 = 0x09;
//operand is zeropage address (hi-byte is zero, address = $00LL) where LL is the byte immediately following the instruction
const zpag: u8 = 0x0A;
//operand is zeropage address; effective address is address incremented by X without carry 
const zpgX: u8 = 0x0B;
//operand is zeropage address; effective address is address incremented by Y without carry **
const zpgY: u8 = 0x0C;


/*
The NES has three different types of interrupt, NMI, IRQ and reset. 
- IRQs are generated by memory mappers, and are triggered by software on 
the BRK instruction. when an IRQ occurs the system jumps to the 16 bit 
address located at 0xFFFE and 0xFFFF

- NMIs are generated by the PPU when we hit a V-Blank at the end of each
frame of. The triggering of a NMI can be prevented if bit 7 of PPU Control 
Register 1 ($2000) is clear. When a NMI occurs the system jumps to the 
address located at $FFFA and $FFFB. 

- Reset interrupts are triggered when the system first starts and when the user presses the reset button. When a reset occurs the system jumps to the address located at $FFFC and $FFFD

The addresses to jump to when an interrupt occurs are stored in a vector 
table in the program code at $FFFA-$FFFF (ie they vary on a per-program 
basis)

When an interrupt occurs the system performs one of the following actions: 
1. Recognize interrupt request has occurred. 
2. Complete execution of the current instruction. 
3. Push the program counter and status register on to the stack. 
4. Set the interrupt disable flag to prevent further interrupts. 
5. Load the address of the interrupt handling routine from the vector table into the program counter. 
6. Execute the interrupt handling routine. 
7. After executing a RTI (Return From Interrupt) instruction, pull the program counter and status register values from the stack. 
8. Resume execution of the program.
*/
pub fn checkInterrupt(currState: &State){

}

pub fn simulateInstruction(currState: &State)->bool{
 let opCode: u8 = bus::read(currState, currState.PC);
 /*
 match opCode{
 //0x00 to 0x0F in the documentation
 0x00 => ops::brk(&currState, impi),
 0x01 => ops::ord(&currState, Xind),
 0x05 => ops::ora(&currState, zpag),
 0x06 => ops::asl(&currState, zpag),
 0x08 => ops::php(&currState, impi),
 0x09 => ops::ora(&currState, imme),
 0x0A => ops::asl(&currState, accu),
 0x0D => ops::ora(&currState, abso),
 0x0E => ops::asl(&currState, abso),
 
 //0x10 to 0x1F
 0x10 => ops::bpl(&currState, rela),
 0x11 => ops::ora(&currState, indY),
 0x15 => ops::ora(&currState, zpgX),
 0x16 => ops::asl(&currState, zpgX),
 0x18 => ops::clc(&currState, impi),
 0x19 => ops::ora(&currState, absY),
 0x1D => ops::ora(&currState, absX),
 0x1E => ops::asl(&currState, absX),

 //0x20 to 0x2F
 0x20 => ops::jsr(&currState, abso),
 0x21 => ops::and(&currState, Xind),
 0x24 => ops::bit(&currState, zpag),
 0x25 => ops::and(&currState, zpag),
 0x26 => ops::rol(&currState, zpag),
 0x28 => ops::plp(&currState, impi),
 0x29 => ops::and(&currState, imme),
 0x2A => ops::rol(&currState, accu),
 0x2C => ops::bit(&currState, abso),
 0x2D => ops::and(&currState, abso),
 0x2E => ops::rol(&currState, abso),

 //0x30 to 0x3F
 0x30 => ops::bmi(&currState, rela),
 0x31 => ops::and(&currState, indY),
 0x35 => ops::and(&currState, zpgX),
 0x36 => ops::rol(&currState, zpgX),
 0x38 => ops::sec(&currState, impi),
 0x39 => ops::and(&currState, absY),
 0x3D => ops::and(&currState, absX),
 0x3E => ops::rol(&currState, absX),
 
 //0x40 to 0x4F
 0x40 => ops::rti(&currState, impi),
 0x41 => ops::eor(&currState, Xind),
 0x45 => ops::eor(&currState, zpag),
 0x46 => ops::lsr(&currState, zpag),
 0x48 => ops::pha(&currState, impi),
 0x49 => ops::eor(&currState, imme),
 0x4A => ops::lsr(&currState, accu),
 0x4C => ops::jmp(&currState, abso),
 0x4D => ops::eor(&currState, abso),
 0x4E => ops::lsr(&currState, abso),
 
 //0x50 to 0x5F
 0x50 => ops::bvc(&currState, rela),
 0x51 => ops::eor(&currState, indY),
 0x55 => ops::eor(&currState, zpgX),
 0x56 => ops::lsr(&currState, zpgX),
 0x58 => ops::cli(&currState, impi),
 0x59 => ops::eor(&currState, absY),
 0x5D => ops::eor(&currState, absX),
 0x5E => ops::lsr(&currState, absX),

 //0x60 to 0x6F
 0x60 => ops::rts(&currState, impi),
 0x61 => ops::adc(&currState, Xind),
 0x65 => ops::adc(&currState, zpag),
 0x66 => ops::ror(&currState, zpag),
 0x68 => ops::pla(&currState, impi),
 0x69 => ops::adc(&currState, imme),
 0x6A => ops::ror(&currState, accu),
 0x6C => ops::jmp(&currState, indr),
 0x6D => ops::adc(&currState, abso),
 0x6E => ops::ror(&currState, abso),

 _ => return false,
 }

 */
 return false;
}

/*
A note:
 Some (late, mostly unlicensed) NES games use unofficial 
 op codes. I am lazy, and thus don't want to implement 
 unofficial op codes with unspecified behavior. Therefore,
 if you want to play any riveting games like the 1994 NES 
 classic *Beauty and the Beast*, this emulator isn't for you!
*/